"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_utils_1 = require("@nestjs/common/utils/shared.utils");
require("reflect-metadata");
const resolvers_enum_1 = require("../enums/resolvers.enum");
const lazy_metadata_storage_1 = require("../schema-builder/storages/lazy-metadata.storage");
const type_metadata_storage_1 = require("../schema-builder/storages/type-metadata.storage");
const reflection_utilts_1 = require("../utils/reflection.utilts");
const resolvers_utils_1 = require("./resolvers.utils");
function Mutation(nameOrType, options = {}) {
    return (target, key, descriptor) => {
        const name = shared_utils_1.isString(nameOrType)
            ? nameOrType
            : (options && options.name) || undefined;
        resolvers_utils_1.addResolverMetadata(resolvers_enum_1.Resolvers.MUTATION, name, target, key, descriptor);
        if (nameOrType && !shared_utils_1.isString(nameOrType)) {
            lazy_metadata_storage_1.LazyMetadataStorage.store(target.constructor, () => {
                const { typeFn, options: typeOptions } = reflection_utilts_1.reflectTypeFromMetadata({
                    metadataKey: 'design:returntype',
                    prototype: target,
                    propertyKey: key,
                    explicitTypeFn: nameOrType,
                    typeOptions: options,
                });
                const metadata = {
                    methodName: key,
                    schemaName: options.name || key,
                    target: target.constructor,
                    typeFn,
                    returnTypeOptions: typeOptions,
                    description: options.description,
                    deprecationReason: options.deprecationReason,
                };
                type_metadata_storage_1.TypeMetadataStorage.addMutationMetadata(metadata);
            });
        }
    };
}
exports.Mutation = Mutation;
